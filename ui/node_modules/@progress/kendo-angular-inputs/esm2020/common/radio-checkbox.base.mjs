/**-----------------------------------------------------------------------------------------
* Copyright © 2024 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { Input, Component, Renderer2, Output, EventEmitter, ViewChild, ElementRef, Injector, ChangeDetectorRef, NgZone, Inject } from '@angular/core';
import { NgControl } from '@angular/forms';
import { guid, hasObservers, isControlRequired, isObjectPresent, isPresent, parseAttributes, removeHTMLAttributes, setHTMLAttributes } from '@progress/kendo-angular-common';
import { COMPONENT_TYPE, getStylingClasses, requiresZoneOnBlur } from './utils';
import * as i0 from "@angular/core";
const FOCUSED = 'k-focus';
const DEFAULT_SIZE = 'medium';
/**
 * @hidden
 */
export class RadioCheckBoxBase {
    constructor(componentType, hostElement, renderer, cdr, ngZone, injector) {
        this.componentType = componentType;
        this.hostElement = hostElement;
        this.renderer = renderer;
        this.cdr = cdr;
        this.ngZone = ngZone;
        this.injector = injector;
        /**
         * @hidden
         */
        this.focusableId = `k-${guid()}`;
        /**
         * Sets the disabled state of the component.
         *
         * @default false
         */
        this.disabled = false;
        /**
         * Specifies the `tabindex` of the component.
         *
         * @default 0
         */
        this.tabindex = 0;
        /**
         * Fires each time the user focuses the component.
         *
         * > To wire the event programmatically, use the `onFocus` property.
         */
        this.onFocus = new EventEmitter();
        /**
         * Fires each time the component gets blurred.
         *
         * > To wire the event programmatically, use the `onBlur` property.
         */
        this.onBlur = new EventEmitter();
        /**
         * @hidden
         */
        this.handleInputBlur = () => {
            this.cdr.markForCheck();
            if (requiresZoneOnBlur(this.control)) {
                this.ngZone.run(() => {
                    this.ngTouched();
                });
            }
        };
        this.focusChangedProgrammatically = false;
        this.parsedAttributes = {};
        this.ngChange = (_) => { };
        this.ngTouched = () => { };
        this._isFocused = false;
        this._size = DEFAULT_SIZE;
    }
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    /**
     * The size property specifies the width and height of the component.
     *
     * @default 'medium'
     *
     * The possible values are:
     * * `small`
     * * `medium`
     * * `large`
     * * `none`
     */
    set size(size) {
        const newSize = size ? size : DEFAULT_SIZE;
        this.handleClasses(newSize, 'size');
        this._size = newSize;
    }
    get size() {
        return this._size;
    }
    /**
     * Sets the HTML attributes of the inner focusable input element. Attributes which are essential for certain component functionalities cannot be changed.
     */
    set inputAttributes(attributes) {
        if (isObjectPresent(this.parsedAttributes)) {
            removeHTMLAttributes(this.parsedAttributes, this.renderer, this.input.nativeElement);
        }
        this._inputAttributes = attributes;
        this.parsedAttributes = this.inputAttributes ?
            parseAttributes(this.inputAttributes, this.defaultAttributes) :
            this.inputAttributes;
        this.setInputAttributes();
    }
    get inputAttributes() {
        return this._inputAttributes;
    }
    ngOnInit() {
        this.control = this.injector.get(NgControl, null);
    }
    /**
     * Focuses the component.
     */
    focus() {
        if (!this.input) {
            return;
        }
        this.focusChangedProgrammatically = true;
        this.isFocused = true;
        this.input.nativeElement.focus();
        this.focusChangedProgrammatically = false;
    }
    /**
     * Blurs the component.
     */
    blur() {
        this.focusChangedProgrammatically = true;
        const isFocusedElement = this.hostElement.nativeElement.querySelector(':focus');
        if (isFocusedElement) {
            isFocusedElement.blur();
        }
        this.isFocused = false;
        this.focusChangedProgrammatically = false;
    }
    /**
     * @hidden
     */
    handleFocus() {
        this.ngZone.run(() => {
            if (!this.focusChangedProgrammatically && hasObservers(this.onFocus)) {
                this.onFocus.emit();
            }
            this.isFocused = true;
        });
    }
    /**
     * @hidden
     */
    handleBlur() {
        this.ngZone.run(() => {
            if (!this.focusChangedProgrammatically) {
                this.ngTouched();
                this.onBlur.emit();
            }
            this.isFocused = false;
        });
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.ngChange = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.ngTouched = fn;
    }
    /**
     * @hidden
     */
    get isControlRequired() {
        return isControlRequired(this.control?.control);
    }
    /**
     * @hidden
     */
    get isControlInvalid() {
        return this.control && this.control.touched && !this.control.valid;
    }
    /**
     * @hidden
     */
    get isFocused() {
        return this._isFocused;
    }
    /**
     * @hidden
     */
    set isFocused(value) {
        if (this._isFocused !== value && this.input) {
            const element = this.input.nativeElement;
            if (value && !this.disabled) {
                this.renderer.addClass(element, FOCUSED);
            }
            else {
                this.renderer.removeClass(element, FOCUSED);
            }
            this._isFocused = value;
        }
    }
    /**
     * @hidden
     * Called when the status of the component changes to or from `disabled`.
     * Depending on the value, it enables or disables the appropriate DOM element.
     *
     * @param isDisabled
     */
    setDisabledState(isDisabled) {
        this.cdr.markForCheck();
        this.disabled = isDisabled;
    }
    get defaultAttributes() { return null; }
    /**
     * @hidden
     */
    writeValue(_value) { }
    handleClasses(value, input) {
        if (!isPresent(this.input)) {
            return;
        }
        const inputElem = this.input.nativeElement;
        const classes = getStylingClasses(this.componentType, input, this[input], value);
        if (classes.toRemove) {
            this.renderer.removeClass(inputElem, classes.toRemove);
        }
        if (classes.toAdd) {
            this.renderer.addClass(inputElem, classes.toAdd);
        }
    }
    setInputAttributes() {
        setHTMLAttributes(this.parsedAttributes, this.renderer, this.input.nativeElement, this.ngZone);
    }
}
RadioCheckBoxBase.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: RadioCheckBoxBase, deps: [{ token: COMPONENT_TYPE }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i0.ChangeDetectorRef }, { token: i0.NgZone }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Component });
RadioCheckBoxBase.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: RadioCheckBoxBase, selector: "ng-component", inputs: { focusableId: "focusableId", title: "title", name: "name", disabled: "disabled", tabindex: "tabindex", tabIndex: "tabIndex", value: "value", size: "size", inputAttributes: "inputAttributes" }, outputs: { onFocus: "focus", onBlur: "blur" }, viewQueries: [{ propertyName: "input", first: true, predicate: ["input"], descendants: true, static: true }], ngImport: i0, template: '', isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: RadioCheckBoxBase, decorators: [{
            type: Component,
            args: [{
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [COMPONENT_TYPE]
                }] }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }, { type: i0.NgZone }, { type: i0.Injector }]; }, propDecorators: { focusableId: [{
                type: Input
            }], title: [{
                type: Input
            }], name: [{
                type: Input
            }], disabled: [{
                type: Input
            }], tabindex: [{
                type: Input
            }], tabIndex: [{
                type: Input
            }], value: [{
                type: Input
            }], size: [{
                type: Input
            }], inputAttributes: [{
                type: Input
            }], onFocus: [{
                type: Output,
                args: ['focus']
            }], onBlur: [{
                type: Output,
                args: ['blur']
            }], input: [{
                type: ViewChild,
                args: ['input', { static: true }]
            }] } });
